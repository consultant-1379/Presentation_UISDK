_private.View_getRoot = View_getRoot;
function View_getRoot() {
    return this.__view__.$el;
}

//noinspection JSUnusedLocalSymbols
_private.View_parseByNames = View_parseByNames;
function View_parseByNames(index, element) {
    var $current = $(element),
        name = $current.data('name'),
        path,
        type;

    if (this[name]) {
        throw new Error('Attribute `' + name + '` exists');
    }
    $current.removeAttr('data-name');

    path = $current.data('widget');
    if (path) {
        require([path], function (Widget) {
            var widget = new Widget(),
                widgetRoot = View_getRoot.call(widget);
            $current.replaceWith(widgetRoot);
            this[name] = widget;
        }.bind(this));
    } else {
        type = $current.data('type');
        this[name] = new Titan.Element($current, {
            name: type || name,
            parent: this
        });
        if (type !== undefined) {
            if (!this[type]) {
                this[type] = [];
            }
            this[type].push(this[name]);
        }
    }
}


/**
 * Extends Backbone.View.
 * See: [http://backbonejs.org/#View](http://backbonejs.org/#View)
 *
 * @class Titan.View
 */
var View = Titan.View = function (options) {
    var node,
        root,
        metaName,
        metaNamespace;

    Utils_configure.call(this, options || {}, ['model', 'collection', 'eventBus']);

    this.__view__ = new Backbone.View();

    this.render();

    if (this.styles) {
        if (this.constructor.prototype.$styles === undefined) {
            node = $.parseHTML('<style>');
            this.constructor.prototype.$styles = $(node).html(this.styles).appendTo('head');
        }
    }

    root = View_getRoot.call(this);
    metaName = root.data('name');
    metaNamespace = root.data('namespace');
    if (metaName && metaNamespace) {
        this.name = metaName;
        this.namespace = metaNamespace;
        this.root = new Titan.Element(root, {
            parent: this
        });
        root.removeAttr('data-name');
        root.removeAttr('data-namespace');
    }

    this.__view__.$('[data-name]').each(View_parseByNames.bind(this));

    this.init();

};

View.extend = Utils_extend;

//noinspection JSUnusedLocalSymbols
View.prototype = {

    /**
     * Generates HTML markup based on a template and model
     *
     * @method template
     * @param model {Titan.Model} The model to be applied to the template
     * @return {String} The markup generated by the template
     */
    template: function (model) {
        return '<div></div>';
    },

    /**
     * Triggered when rendering the View. Checks if it the View is already rendered. If it is, it will remove all
     * events from the View, re-render it, and apply events back to it, otherwise it will render it normally.
     *
     * @method render
     * @return {View} This View is returned to allow for chained methods.
     */
    render: function () {
        if (this.isRendered) {
            var node = $.parseHTML(this.template(this));
            View_getRoot.call(this).replaceWith(node);
            this.__view__.setElement(node);
        } else {
            this.__view__.setElement(this.template(this));
            this.isRendered = true;
        }

        return this;
    },

    /**
     * Method called after the View is initialised. Empty by default, it can be overridden to provide functionality
     *
     * @method init
     */
    init: function () {

    },

    /**
     * Sets the Presenter for this View
     *
     * @method setPresenter
     * @param presenter {Titan.Presenter} The Presenter you wish to set for this View
     * @return {Object} The View object
     */
    setPresenter: function (presenter) {
        this.presenter = presenter;
        return this;
    },

    /**
     * Gets the Presenter for this View
     *
     * @method getPresenter
     * @return {Titan.Presenter} The Presenter for the View
     */
    getPresenter: function () {
        return this.presenter;
    }

};
